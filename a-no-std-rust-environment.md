# 一个no_std的Rust环境

嵌入式编程这一术语被用于广泛的不同类别的编程。
从只有几KB的RAM和ROM的8位MCU（如ST72325xx）的编程，
到像Raspberry Pi（Model B 3+）这样拥有32/64位4核Cortex-A53 @ 1.4 GHz和1GB RAM的系统。
根据你的目标和使用情况，在编写代码时将有不同的限制/约束。

有两种通用的嵌入式编程分类。

## 托管环境

这类环境接近于正常的PC环境。
这意味着你被提供了一个系统接口，如POSIX，它为你提供了与各种系统交互的基元，
如文件系统、网络、内存管理、线程等。而标准库通常依赖于这些基元来实现其功能。
你也可能有某种系统根和对RAM/ROM使用的限制，
也许还有一些特殊的HW或I/O。
总的来说，这感觉就像在一个特殊用途的PC环境中进行编码。

## 裸金属环境

在裸机环境中，在你的程序之前没有加载任何代码。
没有操作系统提供的软件，我们就不能加载标准库。
相反，程序以及它所使用的板条，
只能使用硬件（裸机）来运行。为了防止Rust加载标准库，
请使用no_std。标准库中与平台无关的部分可以通过libcore获得。
libcore也排除了一些在嵌入式环境中并不理想的东西。
其中之一是一个用于动态内存分配的内存分配器。
如果你需要这个或其他功能，通常会有提供这些功能的crack。

## libstd运行
如前所述，使用libstd需要某种系统集成，但这不仅是因为libstd只是提供了一种访问操作系统抽象的通用方法，
它还提供了一个运行时。
这个运行时，除其他事项外，还负责设置堆栈溢出保护，
处理命令行参数，以及在程序的主函数被调用前催生主线程。
在no_std环境下，这个运行时也是不可用的。

## 摘要

`#![no_std]`是一个板块级属性，表示该板块将链接到core-rate而不是std-rate。
而libcore板块是std板块的一个平台无关的子集，
它不对程序将运行的系统进行假设。
因此，它提供了语言基元的API，如浮点、字符串和切片，
以及暴露处理器特性的API，如原子操作和SIMD指令。
然而，它缺乏任何涉及平台整合的API。
由于这些特性，no_std和libcore代码可用于任何类型的引导（阶段0）代码，
如引导程序、固件或内核。
